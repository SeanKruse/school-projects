"""
Assign 04 - <Sean Kruse>

Directions:
    * Complete the graph algorithm functions given below. Note that it may be
      helpful to define auxiliary/helper functions that are called from the
      functions below.  Refer to the README.md file for additional info.

    * NOTE: As with other assignments, please feel free to share ideas with
      others and to reference sources from textbooks or online. However, be
      sure to **cite your resources in your code. Also, do your best to attain
      a reasonable grasp of the algorithm that you are implementing as there
      will very likely be questions related to it on quizzes/exams.

    * NOTE: Remember to add a docstring for each function, and that a
    reasonable coding style is followed (e.g. blank lines between functions).
    Your program will not pass the tests if this is not done!
"""

# for timing checks
import time


def adjMatFromFile(filename):
    """ Create an adj/weight matrix from a file with verts, neighbors, and weights. """
    f = open(filename, "r")
    n_verts = int(f.readline())
    print(f" n_verts = {n_verts}")
    adjmat = [[None] * n_verts for i in range(n_verts)]
    for i in range(n_verts):
        adjmat[i][i] = 0
    for line in f:
        int_list = [int(i) for i in line.split()]
        vert = int_list.pop(0)
        assert len(int_list) % 2 == 0
        n_neighbors = len(int_list) // 2
        neighbors = [int_list[n] for n in range(0, len(int_list), 2)]
        distances = [int_list[d] for d in range(1, len(int_list), 2)]
        for i in range(n_neighbors):
            adjmat[vert][neighbors[i]] = distances[i]
    f.close()
    return adjmat


def prims(W):
    """
    Carry out Prim's algorithm using W as a weight/adj matrix.
    Sources:
        Psuedocode provided by Dr. Geinitz, and pseudocode from
        https://www.freecodecamp.org/news/prims-algorithm-explained-with-pseudocode/
        Some code was completed by Github Copilot as I expanded on the pseudocode.
        Docstring documentation was generated by ChatGPT-3.
    Args:
        W (List[List[int]]): The weight/adjacency matrix of the graph.

    Returns:
        List[Tuple[int, int, int]]: The list of edges in the minimum spanning
        tree with their weights as (v, w, weight).
    """
    # Initialize set of edges to empty
    F = []
    # Initialize set of vertices to empty
    # Initialize set of vertices to contain only the first one
    V = set()
    V.add(0)
    # Number of total vertices in the graph
    n_verts = len(W)
    # While the instance is not solved
    # Run the algorithm until all vertices are in mst
    while len(V) < n_verts:
        min_weight = float("inf")
        min_edge = None

        # Iterate over all vertices in the set of vertices
        for v in V:
            # Iterate over all vertices not in the set of vertices
            for w in range(n_verts):
                if w not in V:
                    # If the weight of the edge is less than the current min
                    if W[v][w] is not None and W[v][w] < min_weight:
                        # Update the minimum weight and edge
                        min_weight = W[v][w]
                        min_edge = (v, w)
        # Add the minimum edge to the set of edges
        F.append((min_edge[0], min_edge[1], min_weight))
        # Add the new vertex to the set of vertices
        V.add(min_edge[1])
    # Check solution
    # if (V == set(range(n_verts))):
    #     print("All vertices are in the set of vertices")
    return F


def dj_sets(vertex, dj_set):
    """ Create disjoints subsets of W,
    one for each vertex and containing only that vertex.
    Args:
        vertex (int): The vertex to find the set representative for.
        dj_set (List[int]): The list representing the disjoint sets.

    Returns:
        int: The representative of the disjoint set containing the vertex.
    """
    if dj_set[vertex] != vertex:
        dj_set[vertex] = dj_sets(dj_set[vertex], dj_set)
    return dj_set[vertex]


def union_sets(vertex1, vertex2, dj_set):
    """
    Union the disjoint sets of vertex1 and vertex2.
    Args:
        vertex1 (int): The first vertex.
        vertex2 (int): The second vertex.
        dj_set (List[int]): The list representing the disjoint sets.
    """
    union_vertex1 = dj_sets(vertex1, dj_set)
    union_vertex2 = dj_sets(vertex2, dj_set)
    dj_set[union_vertex1] = union_vertex2


def sort_key(edge):
    """
    Return the edge weight for sorting purposes.
    Args:
        edge (Tuple[int, int, int]): An edge represented as (v, w, weight).

    Returns:
        int: The weight of the edge.
    """
    return edge[2]


def kruskals(W):
    """
    Carry out Kruskal's algorithm using W as a weight/adj matrix.
    Sources:
        Psuedocode provided by Dr. Geinitz.
        Pseudocode and explanation from:
        https://courses.cs.washington.edu/courses/cse326/06au/lectures/lect24.pdf
        Helper methods dj_sets, union_sets, and sort_key provided by ChatGPT-3,
        when I prompted it with how to handle disjoint and union sets. Later, I
        got stuck on how to sort the edges by weight, so I prompted ChatGPT-3 for
        help with that as well. I ended up moving them into their own methods
        for clarity and to make the code more readable.
    Args:
        W (List[List[int]]): The weight/adjacency matrix of the graph.

    Returns:
        List[Tuple[int, int, int]]: The list of edges in the minimum spanning tree
        with their weights as (v, w, weight).
    """
    # Initialize set of edges to empty
    F = []
    # number of vertices in the graph
    n_verts = len(W)
    # Create a list of edges and sort them by weight
    edges = []
    for i in range(n_verts):
        for j in range(i + 1, n_verts):
            if W[i][j] is not None:
                edges.append((i, j, W[i][j]))
    edges.sort(key=sort_key)
    # Initialize the disjoint sets
    dj_set = [i for i in range(n_verts)]
    # Iterate through the edges
    for edge in edges:
        v, w, weight = edge
        # If the vertices are not in the same set
        if dj_sets(v, dj_set) != dj_sets(w, dj_set):
            # Add the edges to the set of edges
            F.append((v, w, weight))
            # Union the disjoint sets
            union_sets(v, w, dj_set)
            # If the mst is complete, break
            if len(F) == n_verts - 1:
                break
    return F


def assign04_main():
    """ Demonstrate the functions, starting with creating the graph. """
    g = adjMatFromFile("graph_verts100_B.txt")

    # Run Prim's algorithm
    start_time = time.time()
    res_prim = prims(g)
    elapsed_time_prim = time.time() - start_time
    print(f"Prim's runtime: {elapsed_time_prim:.2f}")

    # Run Kruskal's for a single starting vertex, 2
    start_time = time.time()
    res_kruskal = kruskals(g)
    elapsed_time_kruskal = time.time() - start_time
    print(f"Kruskal's runtime: {elapsed_time_kruskal:.2f}")

    # Check that sum of edges weights are the same for this graph
    cost_prim = sum([e[2] for e in res_prim])
    print("MST cost w/ Prim: ", cost_prim)
    cost_kruskal = sum([e[2] for e in res_kruskal])
    print("MST cost w/ Kruskal: ", cost_kruskal)
    assert cost_prim == cost_kruskal


# Check if the program is being run directly (i.e. not being imported)
if __name__ == '__main__':
    assign04_main()
